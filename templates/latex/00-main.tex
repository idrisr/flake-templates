\documentclass[openany, 11pt]{book}
\input{preamble}
\title{My Great Document}
\author{Idris}
\date{September 2024}

\begin{document}
\maketitle{}
\tableofcontents
\tcblistof[\section]{definition}{List of Definitions}
\listoffigures
\listoftables

\chapter{Type Inference}

\begin{enumerate}[label = {(\alph*)}]
	\item asdf
	\item asdf
\end{enumerate}

\begin{intuition}{Type Inference}
	The essense of type inference is walking the abstract syntax tree and
	collect constraints we must satisfy. Therefore we would reformulate the
	problem to so-called unification problem.
\end{intuition}

\begin{definition}{Type Inference}{}
	Figuring out whether an expression $e$ is well-typed, and if so, what it's
	type $T$ is $e: T$.
\end{definition}

\begin{definition}{Type Inference By Hand}{}
	We can approximate this algorithm by
	\begin{enumerate}
		\item assigning a fresh type variable to each bound name
		\item assigning a fresh type variable to the function return value
		\item solving type constraints until there is nothing more to do.
	\end{enumerate}
\end{definition}

\section{Example}
\begin{haskell}{}
	myFun w x y z = if y then w : tail x else y : z
\end{haskell}

\begin{figure}[H]
	\begin{center}
		\input{figures/samples/05-toset.tex}
	\end{center}
	\caption{Toset}
\end{figure}

\section{Example}
\begin{center}
	\begin{forest}
		[\hask{=}
			[\hask{z}
				[\hask{f}]
			]
			[\hask{f}
				[\hask{(,)}
					[\hask{f}
						[\hask{3} ]
					]
					[\hask{f}
						[\hask{3} ]
					]
				]
			]
		]
	\end{forest}
\end{center}


\chapter{Functor}
\epigraph{
	There are two keys to an expert Haskell hackerâ€™s wisdom. First understand
	the types. Next gain a deep intuition for each type class and its
	relationship to other type classes, backed up by familiarity with many
	examples.
}{Brent Yorgey}

% \printbibliography{}
% \printindex{}
\end{document}
