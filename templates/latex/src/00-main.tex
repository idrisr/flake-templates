\documentclass[openany, 12pt]{book}
\input{preamble}
\title{My Great Document}
\author{Idris}
\date{September 2024}

%chktex-file 1
% chktex-file 2999999

\input{glossary}
\makeglossaries

\begin{document}
\maketitle{}
\tableofcontents

\listoffigures
\listoftables

\chapter{Type Inference}

\begin{enumerate}[label = {(\alph*)}]
	\item asdf
	\item asdf
\end{enumerate}

\setboxcounter{intuition}{9}
\begin{intuition}{Type Inference}
	The essense of type inference is walking the abstract syntax tree and
	collect constraints we must satisfy. Therefore we would reformulate the
	problem to so-called unification problem.
\end{intuition}

\begin{definition}{Type Inference}{}
	Figuring out whether an expression $e$ is well-typed, and if so, what it's
	type $T$ is $e: T$.
\end{definition}

\begin{definition}{Type Inference By Hand}{}
	We can approximate this algorithm by
	\begin{enumerate}
		\item assigning a fresh type variable to each bound name
		\item assigning a fresh type variable to the function return value
		\item solving type constraints until there is nothing more to do.
	\end{enumerate}
\end{definition}

\section{Example}
\begin{haskell}{}
	myFun w x y z = if y then w : tail x else y : z
\end{haskell}

\section{Example}

\chapter{Functor\index{Functor}}
\gls{KMS}

\clearpage
\printglossaries

% \printbibliography{}
\printindex{}
\end{document}
